In MySQL, locks are used to control concurrent access to database objects like tables and rows, preventing conflicts and ensuring data consistency. The LOCK TABLES statement allows explicit table-level locking, while InnoDB storage engine uses row-level locking. MySQL also uses metadata locks to manage concurrent changes to database structures. 

Note : To view the connection id----->SELECT CONNECTION_ID();

üîê Types of Locks in MySQL
1. üß± Table-Level Locks
    Applies to: MyISAM, MEMORY, MERGE engines.
    Scope: Entire table.
    Use case: Simple systems with low concurrency or heavy reads.

üî∏ Behavior:
    READ lock: Other sessions can read, but not write.
    WRITE lock: Other sessions cannot read or write.

‚úÖ Example:
LOCK TABLES emp_info READ;       -- Locks for read-only
LOCK TABLES emp_info WRITE;      -- Locks for read/write exclusively
UNLOCK TABLES;

2. üìå Row-Level Locks
    Applies to: InnoDB engine.
    Scope: Individual rows.
    Use case: High-concurrency systems; ensures minimal contention.

üî∏ Benefits:
    High concurrency (many users can read/write different rows).
    Locks are held only within transactions.

‚úÖ Example:
    START TRANSACTION;
    SELECT * FROM emp_info WHERE id = 5 FOR UPDATE;
    -- Row is locked for update by this session
    COMMIT;

3. üóÇÔ∏è Metadata Locks (MDL)
    Scope: Schema objects like tables, views, procedures.
    When used: Every time you query or modify a table or structure.

üî∏ Use cases:
    Prevents changes to table structure during query execution.
    Acquired automatically by MySQL.

‚ö†Ô∏è Example:
-- Session 1
    SELECT * FROM emp_info; -- Implicit metadata lock is held

-- Session 2
    ALTER TABLE emp_info ADD COLUMN age INT; -- Will block until Session 1 finishes

4. üìå Record Locks
    Applies to: InnoDB with indexes.
    Scope: Specific index entries.
    Use case: To prevent others from changing specific indexed rows.

üî∏ Works under the hood of row-level locking:
    Prevents phantom reads and ensures ACID properties.

üîÑ Mixed Lock Example:
    LOCK TABLES orders READ, products WRITE;
    Locks orders for reading: ‚úÖ others can read ‚ùå cannot write.
    Locks products for writing: ‚ùå others cannot read or write.

üß† Key Concepts Summary
Concept	          Description
Read Lock	      Allows multiple sessions to read, but no writing.
Write Lock	      One session can read/write; others are fully blocked.
Deadlock	      Two sessions waiting on each other's locks. Handled by InnoDB 
                  with rollback.
Lock Granularity  Row (fine), Table (coarse), Metadata (DDL-level).

************************************************************************************
Practical
‚úÖ Step 1: Create Database and Table
CREATE DATABASE IF NOT EXISTS employee;
USE employee;

CREATE TABLE emp_info (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    address VARCHAR(100),
    salary FLOAT
) ENGINE=InnoDB;

‚úÖ Step 2: Insert Sample Data
INSERT INTO emp_info (id, name, address, salary) VALUES
(1, 'Ram', 'Hyderabad', 30000),
(2, 'Ravi', 'Vizag', 32000),
(3, 'Rani', 'Chennai', 40000);

üîí Part 1: Table-Level Locks (Using LOCK TABLES)

‚úÖ Step 3: Lock Table in READ Mode
LOCK TABLE emp_info READ;

Only SELECT queries allowed in current session.
Other sessions cannot write to this table.

üö´ Example: Try to write while locked
INSERT INTO emp_info VALUES (4, 'Raju', 'KKD', 45000); -- ‚ùå Will fail in READ lock

‚úÖ Step 4: Unlock Table
UNLOCK TABLES;

‚úÖ Step 5: Lock Table in WRITE Mode
LOCK TABLE emp_info WRITE;
Current session can read/write.

Other sessions are blocked from both reading and writing.

üîê Part 2: Row-Level Locks (InnoDB Only)
These are done inside transactions and affect only selected rows.

‚úÖ Step 6: Lock a Row for Update
START TRANSACTION;

SELECT * FROM emp_info WHERE id = 1 FOR UPDATE;

-- Now this row is locked exclusively for current session.
-- No other session can update this row until COMMIT (they can read).

UPDATE emp_info SET salary = salary + 5000 WHERE id = 1;

COMMIT;

‚úÖ Step 7: Lock a Row for Shared Read
START TRANSACTION;

SELECT * FROM emp_info WHERE id = 2 LOCK IN SHARE MODE;
-- Other sessions can still read, but cannot update this row

-- Read-only logic

COMMIT;

üß† Part 3: Metadata Locks
These happen automatically when running schema changes.

Example:
ALTER TABLE emp_info ADD COLUMN dept VARCHAR(30);
While this is running, other sessions cannot query the emp_info table.

MySQL uses metadata locks to prevent structural inconsistency.

üß© Part 4: Advisory Locks
You can use custom named locks for logic-level coordination.
-- Acquire Lock (waits up to 10 seconds)
SELECT GET_LOCK('emp_processing', 10);  -- returns 1 if successful

-- Do critical section

-- Release Lock
SELECT RELEASE_LOCK('emp_processing');
These are not tied to tables or rows‚Äîjust logical locks for coordination between sessions.

